<style>
table {
margin: auto;
}
</style>
# VeriSim_Compiler<br>以Logisim为目标平台的verilog编译器


| 姓名|学号|
|-----|-----      |
|孟繁瑞|ZY2006239|
|郝  浩 |ZY2006202|


## 设计背景

​     《计算机组成原理》是计算机类各专业本科生必修的硬件课程中的重要核心课。在北航，**计算机组成原理**、**操作系统**、**编译原理**，因其**高标准、高难度、高强度**的课程设计，一直是六系众人肩上的三座大山。自有记载以来，无数仁人志士日以继夜、夜以继日，挑灯夜读、埋头苦干。  
说回《计组课程设计》，作为目前专业分流后的第一门核心专业课的动手环节，目前采用的是Logisim-verilog-mips的理论预习顺序 & logisim-verilog 的CPU构建顺序实现的。作为面向特定领域的语言（Domain Specified Language），verilog实现了将特定的语言对应到硬件模型上。如果学习了verilog，并且有一定的实践经验的编程人员能强烈地感受到，verilog和C/C++等编程语言有着本质且明显的差别。但对于初学者而言，仅在课堂上听高老板一句高屋建瓴的“编程时做到心中有电路”，难以对应到实践中。  
​       因此，先用logisim完成简单电路的设计、单周期CPU的设计帮助学生建立电路构造的 “feel” ，再进行verilog的较复杂CPU设计。这一安排是很合理且成功的，但是在担任计组朋辈助教期间，我负责辅导的同学的课程进度多卡在**Logisim_CPU——Verilog_CPU**之间，说明对于一些同学而言，有限时间内思维方式的快速转换仍有难度。是否有其他方式可以帮助解决这一问题，在这门课上我想到一个解决方案，**反其道而行之**，基于可综合的Verilog生成Logisim电路。  

## 设计思路及相关工作调研

​		在选取基础语言方面，结合开发需求和当前领域内的主要工作进行调研。

高层次综合（Hhigh Level Synthesis）是通过编写C++高级语言代码实现RTL级硬件功能。可以方便已有的C算法代码映射到FPGA上，有点事开发快速，效率高。缺点是综合出来的结果质量落后于RTL的质量，使用门槛较高，只适用于硬件开发的特定领域。

​		Chisel作为基于Scala的语言，在UCB研究团队开发和推动下，目前广泛应用于RISC-V的开发当中。Chisel语言在设计时以Scala为基础，因为Scala中有许多特性适合描述电路，比如它是静态语言，以编译期为主，适合转换成Verilog/VHDL。再比如它的操作符即方法、柯里化（Currying）、纯粹的面向对象、强大的模式匹配、便捷的泛型编写、特质混入、函数式编程等特性，使得用Scala开发DSL语言很方便。Chisel语言不等同于HLS，因为语言没有EDA工具支持，其选择借助verilog，再交付EDA工具实现电路生成。通过Firrtl编译器，将chisel文件转换成firrtl文件，这是一种标准的中间交换格式，方便地让各种高级语言转换到VHDL。其重要特性，一是引入了面向对象的特点，二是减少了不必要的语法，并利用类继承等的特性迅速改变电路结构。缺点是入门门槛极高，调试极复杂，可读性极差。

​		考虑本项目的实现流程，需要将所用语言对电路做一层抽象，做成Logisim库中提供的元器件。Logisim元器件中一部分也为抽象表示，需要在设计时充分考虑元器件的逻辑和逻辑特性。再考虑到入门门槛和开发难度，决定以System-Verilog为蓝本，裁剪不必要的语言特性，重点实现可综合语法的语言到门电路的转换。

**VeriSim语言特性**：

​		1、语法较简单，入门门槛低。

​		2、以可综合电路为目标，完备的语法支持。

​		3、实现硬件语言到可编辑电路图的转换。

## 词法描述

### 1、保留字

​		VeriSim中的保留字，部分是对硬件结构的修饰，例如端口的input/output属性、保留的门电路（and、or、not等），另一部分是时序逻辑、组合逻辑的抽象，如always块、generate块。而initial、real等保留字多用于HDL的验证流程，不可综合，VeriSim不考虑实现。语言的保留字如下：

| module       | endmodule       | input       | output    | wire    | signed     |
| ------------ | --------------- | ----------- | --------- | ------- | ---------- |
| **reg**      | **integer**     | **and**     | **or**    | **xor** | **not**    |
| **generate** | **endgenerate** | **genvar**  | **for**   | **if**  | **else**   |
| **case**     | **endcase**     | **default** | **begin** | **end** | **assign** |
| **always**   | **posedge**     |             |           |         |            |

### 2、运算类型

​		VeriSim支持多种运算符，Logisim本身提供了常见的加减乘除运算器件，可以直接通过VeriSim的对应运算符映射。而对于门电路，也可以支持多位直接比较。赋值运算较为不同。对于组合逻辑，应当通过ASSIGN关键字和“=”进行赋值。但对于时序逻辑，考虑到非阻塞赋值对于代码整体可读性、错误易排查性、构成电路的效率影响，VeriSim仅支持阻塞赋值——即在Always块中使用“<=”对reg变量赋值，无法对wire变量赋值。

​		VeriSim支持的运算类型（EBNF）如下：

````
  unary_binary_op : +=|-=|\*=|/=|%=|&=|\|=|^=|<<=|>>=|**|//=|==|<=|>=|<<|>>|[<>%^&\?+/=~\-\*] 
````

### **3、其他符号**

​		数字：VeriSim支持两类数字，一种为普通十进制数字类型，另一种为格式化数字，即 **位数 '	进制  数值** 表示，如32'h6789ABCD

​		标识符：除保留字外的变量名

​		构成语法的其他符号````[@:,.`;]````、各种括号```` [(){}[\]]```` 

## **语法描述**

本节主要用EBNF描述VeriSim语法，并针对主要语法表达式解释其语法含义。

- identifier: 
	- ident
- system_name:
	- sysname
- real_number:
	- **realnum**
- natural_number:
    - **natural**
- string:
    - **string**
- unary_operator:
  - **+|-|!|\~|&|\~&|  \|  | \~| | ^ | ~^ | ^~**
- binary_operator:
  - **+|-|*|/|%| =\= | != | === | !\== | && | || | ** |< | <= | > |  >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<** 

---
电路图的声明从<translation_unit>开始，<module_declaration>声明了模块的输入输出端口
- translation_unit :   
  - module_declaration
- module_declaration :   //去掉了parameter_port_list
  - **module** module_identifier [ **(** [list_of_ports | list_of_port_declarations] **)** ] **;** { module_item  } **endmodule**  

- list_of_ports:  
	- port{ **,** [port]}
- list_of_port_declarations: 
	- port_declaration { **,** port_declaration }
- port:
	- port_expression | **.**port_identifier **(** [ port_expression ] **)**
- port_expression:
	- port_reference | **{** port_reference  { , port_reference } **}**  
- port_reference :
	- port_identifier[ **[** constant_range_expression **]**  ]   
- port_declaration: 
	- input_declaration | output_declaration   

- module_item :
	- port_declaration **;**
	- non_port_module_item
- module_or_generate_item :
	- module_or_generate_item_declaration  
	  | continuous_assign  
	  | gate_instantiation  
      | always_construct    
      | loop_generate_construct
      | conditional_generate_construct  

- module_or_generate_item_declaration : 
	- net_declaration | reg_declaration | integer_declaration 
	 | real_declaration 
	 | genvar_declaration 
  
- non_port_module_item :
	- module_or_generate_item
	| generate_region

- input_declaration :
  - **input** [ **wire** ] [ **signed** ] [ range ] list_of_port_identifiers

- output_declaration :
  - **output** ( [ **wire** ] [ **signed** ] [ range ] list_of_port_identifiers | **reg** [ **signed** ] [ range ] list_of_variable_port_identifiers | **interger** list_of_variable_port_identifiers )  
- integer_declaration :
  - **integer** list_of_variable_identifiers **;**

- list_of_net_decl_assignments_or_identifiers :
	- net_identifier [ dimension { dimension } | **=** expression ] { **,** net_identifier [ dimension { dimension } | **=** expression ] }

- net_declaration :
	- **wire** [ **signed** ] [ range ] list_of_net_decl_assignments_or_identifiers **;**  //delay strength vector 去掉亄1�7
- real_declaration :
  - **real** list_of_real_identifiers **;**

- reg_declaration :
  - **reg** [ **signed** ] [ range ] list_of_variable_identifiers **;**

- real_type :
	- real_identifier ( { dimension } | **=** constant_expression )

- variable_type :
	- variable_identifier ( { dimension } | **=** constant_expression )

- list_of_port_identifiers :
	- port_identifier { **,** port_identifier }

- list_of_real_identifiers :
	- real_type { **,** real_type }

- list_of_variable_identifiers :
  - port_identifier [ **=** constant_expression ] { **,** port_identifier [ **=** constant_expression ] }

- dimension :
	- **[** dimension_constant_expression **:** dimension_constant_expression **]**

- range :
	- **[** msb_constant_expression **:** lsb_constant_expression **]**

- gate_instantiation :
	-   n_input_gatetype  n_input_gate_instance { **,** n_input_gate_instance } **;**
		| n_output_gatetype  n_output_gate_instance { **,** n_output_gate_instance } **;**
- n_input_gate_instance :
	- [ name_of_gate_instance ] **(** output_terminal **,** input_terminal { **,** input_terminal } **)**

- n_output_gate_instance :
	- [ name_of_gate_instance ] **(** input_or_output_terminal { **,** input_or_output_terminal } **)**
- output_terminal :
  - net_lvalue
- input_terminal :
  - expression
- input_or_output_terminal :   //expression_2 不太懂结构，也没有在本文给出
  - expression_2   
- name_of_gate_instance :
	- gate_instance_identifier **[** range **]**

- n_input_gatetype :
    - **and
    | nand
    | or
    | nor
    | xor
    | xnor**

- n_output_gatetype :
  - **not**

- generate_region :
	- **generate** { module_or_generate_item } **endgenerate**  //dormouse也许会去掉
  
- genvar_declaration :
  - **genvar** list_of_genvar_identifiers **;**  //dormouse也许会去掉

- list_of_genvar_identifiers :
	- genvar_identifier { **,** genvar_identifier }
  
- loop_generate_construct :
	- **for** **(** genvar_initialization **;** genvar_expression **;** genvar_iteration **)** ( generate_block | module_or_generate_item )

- genvar_initialization :
    - genvar_identifier **=** constant_expression

- genvar_expression :
	- [ unary_operator ] genvar_primary genvar_expression_nlr
- genvar_expression_nlr :
	[ binary_operator genvar_expression genvar_expression_nlr
	| **?** genvar_expression **:** genvar_expression genvar_expression_nlr ]

- genvar_iteration :
	- genvar_identifier **=** genvar_expression


- genvar_primary :
	- constant_primary

- conditional_generate_construct :
	- if_generate_construct
	| case_generate_construct

- if_generate_construct :
     **if (** constant_expression **)** generate_block_or_null [ **else** generate_block_or_null ]


- case_generate_construct :
	- **case** **(** constant_expression **)** case_generate_item { case_generate_item } **endcase**


- case_generate_item :
	- constant_expression { **,** constant_expression } **:** generate_block_or_null
| **default** [ **:** ] generate_block_or_null

- generate_block :
**begin** [ **:** generate_block_identifier ] { module_or_generate_item } **end**

- generate_block_or_null :
generate_block
| module_or_generate_item
| **;**

- continuous_assign :
	- **assign**  list_of_net_assignments **;**

- list_of_net_assignments :
	- net_assignment { **,** net_assignment }
- net_assignment :
	- net_lvalue **=** expression
- initial_construct :
	- **initial** statement
- always_construct :
	- **always** statement

- procedural_continuous_assignments :
	- **assign** variable_assignment
- variable_assignment :
	- variable_lvalue **=** expression

- seq_block :
	- **begin** [ **:** block_identifier { block_item_declaration } ] { statement } **end**
- blocking_or_nonblocking_assignment_or_task_enable :
	variable_lvalue [ **(** expression { **,** expression } **)** ] [ ( **<=** | **=** ) [ delay_or_event_control ] [ expression ] ] **;**
- statement :
	- blocking_or_nonblocking_assignment_or_task_enable
	| case_statement
	| conditional_statement
	| loop_statement
	| procedural_continuous_assignments ;
	| seq_block
	| ;

- statement_or_null :
	- [ statement ]
- delay_or_event_control :
 	- event_control

- event_control :
	- **@** ( **(** ( event_expression | **\*** ) **)** | **\*** | hierarchical_event_identifier )

- hierarchical_event_identifier : //可能用不到，这里不给出内容，详见markdown原文
	<!-- -hierarchical_identifier
      - hierarchical_identifier :
    	- identifier [ [ constant_expression ] ] { . identifier [ [ constant_expression ] ] } -->


- event_expression :
  - **posedge** expression event_expression_nlr |
    expression event_expression_nlr
- event_expression_nlr :
	- [ **or** event_expression event_expression_nlr
| **,** event_expression event_expression_nlr ]

- conditional_statement :
**if** **(** expression **)** statement_or_null [ **else** statement_or_null ]

-  case_statement :
**case** **(** expression **)** case_item { case_item } **endcase**

- case_item :
expression { **,** expression } **:** statement_or_null
| **default** [ **:** ] statement_or_null

- loop_statement :
	- **for** **(** variable_assignment **;** expression **;** variable_assignment **)** statement

- constant_expression :
	- [ unary_operator ] constant_primary { constant_expression_nlr }

- constant_expression_nlr:
  - binary_operator constant_expression
| **?** constant_expression **:** constant_expression

- expression :
	- [ unary_operator ] primary { expression_nlr }


- expression_nlr :
  - binary_operator expression
| **?** expression **:** expression

- lsb_constant_expression :
	- constant_expression

- constant_primary :
	-	number
		| string
		<!-- | **(** constant_mintypmax_expression **)** -->
		| ( identifier | system_name ) [ **[** constant_range_expression **]** | **(** constant_expression { **,** constant_expression } **)** ]
		| **{** constant_expression [ **,** constant_expression { **,** constant_expression } | **{** constant_expression { **,** constant_expression } **}** ] **}**


- primary :
	-  hierarchical_identifier_range   [ **(** expression { **,** expression } **)** ]
	| number
	| string
	<!-- | **(** mintypmax_expression **)** -->
	| **{** expression [ **,** expression { **,** expression } | **{** expression { **,** expression } **}** ] **}**

- hierarchical_identifier_range :
	- identifier { **.** identifier [ **[** range_expression **]** ] | **[** range_expression **]** }

- range_expression :
	- expression [ **:** lsb_constant_expression ]
- net_lvalue :
	- hierarchical_identifier_range_const
		| **{** net_lvalue { **,** net_lvalue } **}**	


- hierarchical_identifier_range_const :
	- identifier { **.** identifier [ **[** constant_range_expression **]** ] | **[** constant_range_expression **]** }
  
- variable_lvalue :
	- hierarchical_identifier_range
		| **{** variable_lvalue { **,** variable_lvalue } **}**

- variable_or_net_lvalue :
	- hierarchical_identifier_range
		| **{**variable_or_net_lvalue { **,** variable_or_net_lvalue } **}**



- number :
	- real_number
	| natural_number [ based_number | base_format ( base_value | natural_number ) ]
	| sizedbased_number
	| based_number
	| base_format ( base_value | natural_number )

- based_number :
	- **BASEDINT**
- base_value :
	- **BASEVAL**
- sizedbased_number:
  - **SIZEVAL**
- base_format :
	- **BASEFMT**


- constant_range_expression :
	- constant_expression [ **:** lsb_constant_expression  ]
- list_of_variable_port_identifiers :
	- port_identifier [ **=** constant_expression ] { **,** port_identifier [ **=** constant_expression ] }

- module_identifier:
  - identifier

- port_identifier : 
  - identifier
- net_identifier : 
  - identifier

- gate_instance_identifier :
	- identifier
- genvar_identifier :
  - identifier
- block_identifier :
  - identifier
- dimension_constant_expression :
	- constant_expression

- msb_constant_expression :
	- constant_expression
- generate_block_identifier :
	- identifier

